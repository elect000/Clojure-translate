# This is a Bibtex reference
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:t arch:headline ^:nil
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:nil e:nil email:nil f:t inline:t num:nil
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:nil title:t toc:t todo:t |:t
#+TITLE: Clojure for the Brave and True
#+DATE: 
#+AUTHOR: elect
#+EMAIL: e.tmailbank@gmail.com
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 24.5.1 (Org mode 9.1.1)
#+LATEX_CLASS: koma-article
#+LATEX_CLASS_OPTIONS: 
#+LATEX_HEADER_EXTRA: \bibliography{reference}
#+LaTeX_CLASS_OPTIONS:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE: 日本語意訳
#+STARTUP: indent overview inlineimages
* はじめに
  　このページは[[https://www.braveclojure.com/getting-started/][Clojure for the Brave and True]]の日本語意訳です。何か問題がありましたら、Issueに上げて頂けると幸いです。
* 第1章 Clojure REPLを動かしてみよう
  この章では、手っ取り早くClojureという言語を触ってみるための章です。何事も百聞は一見に如かず、まずは書いてみましょう。書いてみることで既にClojureを書いている同士達と経験を共有することができます。つまりは皆さんのモチベーションを上げることにつながるのです。

　そして私達は、この言語を学ぶにあたりREPL(Read Eval Print Loop)を用いることで書いたコードを即座に実行することができます。REPLとはPythonのインタプリタのようなものです。これにより、言語理解を加速させ効率的な学習をすることができます。

　さて、まずはClojureについて簡単に紹介していきます。ここで用いるのは、Clojureのビルドツールである、Leiningenです。C言語で言うgccのようなものだと考えて頂いて構いません。この章では以下のLeiningenの機能を紹介していきます。
- Leiningenで新しいプロジェクトを作成する
- プロジェクトをビルドして実行可能なjarファイルを作成する(.exeファイルのようなものです)
- Clojure REPLでコードを実行する
** Clojureとは何か
   　Clojureとは、Rich Hickeyによってかの至高の言語Lispをベースにして作成されました。Lispには他の言語では得がたい表現力の高いコードを描く能力があります。明解な関数プログラミングであるこの言語を学ぶことにより、私達はプログラマーとしてより高度な思考能力を身につけることができます。さらにClojureは、並行プログラミングのような伝統的に複雑とされてきた課題を解決するための優れたツールを用意しています。

   　しかし忘れてはならないことに、Clojureという言語そのものとClojureコンパイラとの区別を知っておくことがあります。Clojureは構文、関数型の表現を重視したLispの方言ではありますが、実装の方は独立しています。このコンパイラはjarファイル、 =つまりclojure.jar= の出力が出来るものであり、これはClojureでかかれたコードを、JVM(Java Virtual Machine)バイトコードでコンパイルします。ClojureのコンパイラはClojureとJava両方の言語と、Javaコンパイラを参照しているものであり、つまりClojureという言語そのものとは別のものなのです。

   　Ruby、Python、C、bazillionなどのプログラミング言語とは異なって、Clojureは =hosted language= です。ClojureプログラムはJVM上で実行されるため、JVMのスレッド処理やガベージコレクションなどの機能の影響を受けます。ClojureはさらにJavaScript(ClojureScriptという名前で人気を得ています)、Microsoft Common Language Runtime(CLR)、といった言語にも注目していますが、ここではそちらの領域まで触れず、JVM上で実装されるClojureについてのみ言及していきます。

   　さらに詳しいClojureとJVMの関係については後述しますが、最低限理解しておくべき概念は以下のものです。
   - JVMのプロセスはJavaバイトコードを実行します
   - 通常、JavaコンパイラはJavaのソースコードからJavaバイトコードを生成します。
   - jarファイルはJavaバイトコードの集合です。
   - Javaプログラムは通常、jarファイルとして配布されます。
   - Javaプログラムである =clojure.jar= はClojureソースコードを読んで、Javaバイトコードを生成します。
   - そのJavaバイトコードは =clojure.jar= を実行したものと同じのJVMプロセスで実行されます。

   　Clojureは日々進化しています。今あなたが見ているClojureのバージョンがこの文章で触れているものよりも新しいかもしれませんが、これについて心配する必要がありません。この文章では基本的な(Clojureのバージョンに関係がない)内容についての説明を行うので、この文章が古いものなのではないかと心配する必要はありません。

   　さて、Clojureが何であるのかを理解できたと思いますので、次は実際にClojureプログラミングに触れていきましょう。

** Leiningen
　今日の多くのClojureユーザはプロジェクトのビルドと設定にLeiningenを使っています。後述する付録AではLeiningenの詳細な使い方を学ぶことができますが、ここでは4つのタスクについてのみに焦点を当てていきます。
1. 新しいClojureプロジェクトの作成
2. Clojureプロジェクトの実行
3. Clojureプロジェクトの構築
4. REPLの使用

　続行する前に、Javaバージョン1.6以降がインストールされていることを確認してください。端末で ~java -version~ してバージョンを確認し、最新の[[http://www.oracle.com/technetwork/java/javase/downloads/index.html][Java Runtime Environment(JRE)]]をダウンロードしてください。次に、[[http://leiningen.org/][Leiningenのホームページ]](WindowsユーザはWindowsインストーラがあることに注意してください)の手順に従ってLeiningenをインストールしてください。Leiningenをインストールすると、自動的にClojure compiler、clojure.jarがダウンロードされます。


** 新しいClojureプロジェクトの作成
　新しいClojureプロジェクトの作成は非常に簡単です。まず1つのLeiningenコマンドがプロジェクトスケルトンを作成してみましょう。後で、Clojureライブラリを組み込むなどの応用を実行する方法を学習しますが、これから行うプロジェクトではそのような拡張せずとも作成したコードを実行することができます。

　それでは早速端末で以下のコマンドをタイプしてClojureのプロジェクトを作成してみましょう。

#+BEGIN_SRC shell
lein new app clojure-noob
#+END_SRC

　このコマンドはclojure-noobというプロジェクトを作成して、以下のような階層のファイル群を作成します。(多少の変更があるかもしれませんが、全く気にすることではありません)

#+BEGIN_SRC text
| .gitignore
| doc
| | intro.md
| project.clj  1
| resources    2
| src
| | clojure-noob
| | | core.clj 3
| test         4
| | clojure-noob
| | | core_text.clj
#+END_SRC

　このプロジェクトスケルトンは、本質的には特別なものではありません。Leiningenが使用している骨組みです。アプリケーションをビルドする際には、このような階層構造が出来ていることをLeiningenは要求します。番号を振っている最初のファイル =project.clj= は、Leiningenの設定ファイルです。このファイルは「このプロジェクトにはどのような依存関係がありますか？」「このClojureプログラムが実行されているとき、最初にどの機能を実行するのですか？」などの問題を解決するのに役立ちます。

　一般に、 =src/<project_name>= にソースコードを保存します。この場合、3の =src/clojure-noob/core.clj= ファイルは中心となるClojureコードを書く場所です。4にテストが格納されているのは明らかでしょう。2は画像のようなアセットなどを保存する場所です。


** Clojureプロジェクトを実行する
　実際にプロジェクトを実行してみましょう。 =src/clojure-noob/core.clj= を好きなエディタで開いてみてください。おそらく以下のようなソースコードが読めるはずです。

#+BEGIN_SRC clojure
(ns clojure-noob.core \\ 1
(:gen-class))

(defn -main \\ 2
"I don't do a whole lot...yet"
[& args]
 (println "Hello, World!")) \\ 3
#+END_SRC

　一行目では名前空間を宣言していますが、今のところ深く考察する必要はありません。2のメイン関数である ~-main~ はプログラムの開始地点であり、付録Aに書かれている話題の一つです。そして、最後の3は以下のように置き換えてください。 ~"Hello, World!" "I'm a little teapot!" (println "I'm a little teapot"))~

  次に端末の =clojure-noob= ディレクトリに移動し、次のように入力してください。

  #+BEGIN_SRC shell
lein run
  #+END_SRC

  おそらくティーポットがあなたに小さな挨拶をしていることでしょう。
  この本を読み進めていけば、このプログラムがどのようなことを行っているのかを字流ことが出来ますが、今のところ知っておくべきことは、私達が関数を作成しそのメイン関数がコマンドライン上のlein runで実行されたことです。


** Clojureプロジェクトの構築
　 ~lein run~ はあなたの書いたコードを実行する素晴らしい手段の一つですが、leiningenをインストールしていない他の人々と成果を共有するにはどのようにすれば良いでしょうか？そのためには、私達はプロジェクトを、Javaのインストールされた環境(つまりほとんど一般的な環境)でスタンドアロンで動く実行形態のファイルに出力しなければなりません。このファイルを出力するためには、以下のコマンドを実行してください。

#+BEGIN_SRC shell
lein uberjar
#+END_SRC

　このコマンドは =target/uberjar/cojure-noob-0.1.0-SNAPSHOT-standalone.jar= を作成します。このファイルを実行するには、続けて以下のコマンドを実行してください。

  #+BEGIN_SRC shell
java -jar target/uberjar/clojure-noob-0.1.0-SNAPSHOT-standalone.jar
  #+END_SRC

　このコマンドによってあなたは、実績のあるファイル形式(jarファイル)としてあなたのプロジェクトを出力できました。つまりこれであなたはほとんどすべての環境でこのプロジェクトを実行することができるようになったのです。

　ここまでであなたはClojureの基本的なビルド、実行、そして極めて基本的なClojureプログラミングについて知ることができました。この後の章では、今実行したコマンドのより詳細なLeiningenの内部動作について学び、ClojureとJVMとの関係と作成したコードの実行方法を完璧に理解することができます。

　第二章では、Emacsの不思議と栄光について話し合いますが、その前に別の重要なツールであるREPLを紹介します。

** REPLを使ってみよう
　REPLはコードを試験するためのツールであり、実行中のプログラムと対話することができ、思いついたアイデアを即座に試すことができます。REPLはコードを入力し逐次実行するためのプロンプトを提供します。そして私達の入力を =読み取り= 、 =評価= し 、結果を =出力= し、 =ループ= を繰り返しプロンプトを再度表示します。

　このプロセスによってClojureは、ほとんどの他言語では不可能な迅速なフィードバックサイクルが可能です。Clojureの理解度を素早く確認できるので、適宜使用することを強くおすすめします。また、Lispの経験をするためにもREPLを用いた開発は非常に意義あるものです。この素晴らしい機会を逃さないためにもぜひともREPLを使っていきましょう。

　REPLを起動するためには、次のコマンドを実行してください。

#+BEGIN_SRC shell
lein repl
#+END_SRC

  出力はおそらく以下のようになるでしょう。

  #+BEGIN_SRC shell
nREPL server started on port 28925
REPL-y 0.1.10
Clojure 1.7.0
    Exit: Control+D or (exit) or (quit)
Commands: (user/help)
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
          (user/sourcery function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
Examples from clojuredocs.org: [clojuredocs or cdoc]
          (user/clojuredocs name-here)
          (user/clojuredocs "ns-here" "name-here")
clojure-noob.core=>
  #+END_SRC

　最後の行である ~clojure-noob.core=>~ はあなたが ~clojure-noob.core~ という名前空間にあることを示しています。こ名前空間ではでは現在 ~-main~ 関数だけが定義されています。早速実行してみましょう。

#+BEGIN_SRC clojure
clojure-noob.core=> (-main)
I'm a little teapot!
nil
#+END_SRC
  
　素晴らしい！これで私達は関数を呼び出して評価することができました。いくつかの基本的なClojureの関数を試してみましょう。

#+BEGIN_SRC clojure
clojure-noob.core=> (+ 1 2 3 4)
10
clojure-noob.core=> (* 1 2 3 4)
24
clojure-noob.core=> (first [1 2 3 4])
1
#+END_SRC

　これも面白い結果を得ることができました。ここではいくつかの数字を足し、掛け、そしてベクトルの最初の要素を取り出したのです。それと同時に私達は特徴的なLispの構文を目にしたことになります。それはすべてのLisp、もちろんClojureにも採用されているポーランド記法の表記です。この構文はまずオペレータ（関数）が式の最初に出てくることを意味しています。今の文を難しく感じたとしても、心配することはありません。Clojureの構文については今後わかりやすく解説が行われます。

　概念的には、REPLはSSH(Secure Shell)に似ています。SSHを使用してリモートサーバとやり取りをするのと同じ方法で、Clojure REPLは実行中のClojureプロセスと対話することができます。この機能は非常に強力であり、例えばREPLを埋め込んだライブプロダクションアプリでは実行中にコードを変更しそれを反映させることができます。ただしREPLを使用したClojureの構文とその意味について詳しく知っている必要があることには注意しなければなりません。

　もう一つ注意しなければならないことは、この文章ではREPLのプロンプト無しでコードのみを掲載していますが、以下のようにコードを試してみてください。

  #+BEGIN_SRC clojure
(do (println "no prompt here!")
   (+ 1 3))
; => no prompt here!
; => 4
  #+END_SRC
  
　 ~;=>~ はREPLで実行した際の出力と返り値を示します。この場合は上の関数を実行した結果が表示されており、 ~; => no prompt here~ が出力で、 ~; => 4~ が返り値になります。

** Clojureの編集ツール
　この時点でClojure言語を学ぶために必要な、エディタや統合開発環境（IDE）の基礎知識が必要です。もしあなたが、Clojureの強力なエディタについての良いチュートリアルが必要な場合には、Clojureユーザに極めて人気の高いEmacsについての説明を第2章で行います。Clojureの開発にはEmacsを使わなければならない、ということは全くありませんが、EmacsはClojure REPLとの親密な関係を持った機能があり、Lispコードの作成に適しています。しかし何よりも忘れてはならないのは、開発環境はあなたに最も適したものを使用するべきだということです。

　Emacsがあなたに合わない場合のために、Clojure開発のための他のテキストエディタとIDEを設定するためのいくつかの解説を紹介します。

- このYoutubeの動画はSublime Text2 でClojureの開発を行う場合の設定について説明しています。[[https://www.youtube.com/watch?v=wBl0rYXQdGg][Clojure development with Sublime Text 2]]
- こちらはClojureの開発をVimで行いたい際に見るべき素晴らしい入門サイトです。[[https://mybuddymichael.com/writings/writing-clojure-with-vim-in-2013.html][Writing Clojure With Vim In 2013]]
- ClojureのEclipseのプラグインはこちらです。[[https://github.com/laurentpetit/ccw/wiki/GoogleCodeHome][GoogleCodeHome]]
- IntellijユーザのためのClojure開発環境であるCursive Clojureです。[[https://cursiveclojure.com/][Cursive Clojure]]
- Nightcodeは無料で簡潔なClojure開発環境です。[[https://github.com/oakes/Nightcode/][Nightcode]]

** この章のまとめ
　素晴らしいことにあなたは今回小さなティーポットについてのClojureプログラムを作成することができました。そしてClojureソフトウェアを作成する際に最も重要なツールの一つであるREPLについて触れることもできました。原作者にとってのヒーローの一人である"Long Live"の登場人物から引用するならば以下のような言葉がふさわしいでしょう。

#+BEGIN_SRC text
You held your head like a hero
On a history book page
It was the end of a decade
But the start of an age
—Taylor Swift
#+END_SRC
* 第2章 Emacsの使い方
　Clojureを身につけるにあたって、あなたのエディタはあなたに最も真摯な味方です。Emacsを使って作業することを強くおすすめしますが、もちろんあなたの使いたいエディタを使用することができます。この章のEmacsの設定に従わない場合や、別のエディタを使いたいと考えた場合には、REPLの設定をするために少しばかりの時間が必要となる可能性があります。

　私がEmacsをおすすめする理由は、Clojure REPLとの親密な統合が提供されることです。これによって書いているときにすぐにコードを試してみることができます。このようなタイトなフィードバックループは、Clojureを学ぶ際に非常に役立ちます。EmacsはLispの方言で書かれており、他の作業を行う際にも強力なツールとなります。

　この章の最後で、Emacsの設定は図2-1のようになります。
[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-final.png][図2-1:典型的なEmacsの設定]]

　ここに到達するためには、まずEmacsをインストールし、新しい人に優しいEmacs設定をセットアップします。次に、ファイルの開き方、編集方法、保存方法、重要なキーバインディングを使ってEmacsとやりとりする方法の基本を学びます。最後に、Clojureコードを実際に編集してREPLとやりとりをする方法を学びます。

** インストール 
　あなたが作業しているプラットフォームには、Emacsの最新のメジャーバージョン(Emacs 25やEmacs 24)を用いるべきです。
- OS X Mac appとして[[http://emacsformacosx.com/][vanilla Emacs]] をインストールします。Aquamacsのような他のオプションはEmacsをもっと「Macのような」ものにするはずですが、標準的なEmacsとはまったく異なって設定されているため、長期的な使用には問題があるかもしれません。
- Ubuntu [[https://launchpad.net/~cassou/+archive/emacs][emacs]]の支持に従ってください。
- Windows [[https://github.com/chuntaro/NTEmacs64][NTEmacs]]を使うことをおすすめします。
- その他のおすすめ [[https://qiita.com/ayato_p/items/10f61995cdc21c2d1927][Spacemacs]] などの利用はVimユーザにもフレンドリーなEmacsの派生です。こちらを用いた場合は以下に説明している設定ではなくリンク先の設定を参照してください。

　Emacsをインストールしたら、それを開いてください。図2-2のようなものが表示されます。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-fresh.png][図2-2:最初にEmacsを開いたときに表示される画面]]

** 構成
　Clojure用にEmacsを設定するために必要なすべてのファイルのリポジトリが作成されています。これは[[https://github.com/flyingmachine/emacs-for-clojure/archive/book1.zip]] にあります。これをEmacsに取り込むためには以下の手順を踏む必要があります。

1. Emacsを閉じます
2. ~/.emacs.d フォルダを削除してください。(WindowsユーザはC:\Users\your_user_name\AppData\Roaming\にあるはずです)Emacsが設定ファイルを探す場所で、これらを削除し入れ替えることでEmacsの設定を変更しようとしているのです。
3. 上記のzipファイルをダウンロードし、解凍します。そして出てきたemacs-for-clojure-book1というフォルダを.emacs.dのあった場所に移動し、.emacs.dという名前に変更してください。
4. ~/.lein/profiles.clj ファイルを作成してください。(Windowsユーザは、おそらくC:\Users\your_user_name\.lein\profiles.clj を作成します)そして以下の行を追加して下さい。
     #+BEGIN_SRC clojure
{:user {:plugins [[cider/cider-nrepl "0.8.1"]]}}
#+END_SRC
5. Emacsを開いてください。

　あなたがEmacsを開いたとき、Emacsは自身のいくつかの拡張パッケージをダウンロードします。このアクティビティが終了した後はEmacsを再起動して下さい。すると図2-3のようなウィンドウが表示されます。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-configged.png][図2-3:設定をインストールした後のEmacsの初期画面]]

** Emacsの緊急停止コマンド
　Ctrl-g はEmacsの重要で基本的な緊急停止コマンドです。このコマンドを実行することでうまくいかないEmacsコマンドを停止させることができ、再実行を可能にすることができます。このコマンドによってEmacsが異常終了したり、編集していたファイルが消失することはありません。あなたの行った現在の行動をキャンセルするだけです。

** Emacsバッファ
　すべての編集作業はEmacsバッファで行われます。最初にEmacsを起動すると、=*scratch*= バッファが開いています。基本的なEmacsではウィンドウの一番下に現在のバッファ名を表示します。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-buffer-name.png][図2-4:Emacsは現在のバッファ名を表示しています]]

　デフォルトでは =*scratch*= バッファはLispの開発に最適化された括弧とインデントの解釈をおこなますが、プレーンテキストを編集する際には不便です。そのため新しいバッファを作成し、そこでプレーンテキストを快適に編集しましょう。以下のシーケンスを実行しましょう。

1. Ctrl+xを同時押し
2. bキーを押す

　これを省略して書く際には ~C-x b~ となります。

　このシーケンスを実行すると、図2-5に示すように、アプリケーションの下部にプロンプ​​トが表示されます。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-buffer-prompt.png][図2-5:ミニバッファはEmacsから入力を求めるプロンプトです]]

　この領域はミニバッファと呼ばれ、Emacsが入力を求めるところです。今すぐバッファ名を入力してみましょう。すでに開いているバッファ名を入力することもできますし、新しいバッファ名を入力することもできます。 =emacs-fun-times= と入力してみましょう。するとバッファ名が =emacs-fun-times= になっていると思います。このバッファ内では基本的なテキスト入力はおそらくあなたの期待した通りの機能を示すと思います。一般キーの入力時には文字が表示され、矢印キーに対しては移動ができ、Enterキーでは新しい行を作成することができます。

　あなたはおそらくEmacsがそこまで難しいことをしているわけではないことに気づくでしょう。これによってあなたがEmacsが気難しいツールなのではないかという不安を払拭することができるでしょう。もしあなたがこのバッファを消したいと考えたならば、C-x k Enterを入力することでこのバッファを削除することができます。(つまり、その場、バッファをkillするということです)

　先のコマンドによってあなたは =emacs-fun-times= というバッファを削除したことになり、おそらく =*scratch*= バッファに遷移したと思います。一般的に、あなたは望む限りの
バッファを C-x b シーケンスを実行することで作成することができます。また、同じシーケンスでバッファ間のスムーズな移動もできます。しかしながら、あなたが作成したバッファは C-x C-s でセーブされるまではメモリ上に存在するだけです。バッファを作成しても必ずしもそれに対応したファイルがどこかに作成されるわけではないということに注意してください。さて、基本的なバッファについての説明が終わったところで、ファイルの操作について説明しましょう。

** ファイルの操作
　Emacsでファイルを開くためのキーバインディングはC-x C-f です。そうすると入力を受け付けるミニバッファのプロンプトが表示されます。 ~〜/.emacs.d/customize/ui.el~ を入力してみましょう。Emacsはこの入力を読んで、このファイル名と同じ名前のバッファを作成しそこにそのファイルを開きます。37行目に進み、(~M-x goto-line Enter 37 Enter~ / Altキー＋xを入力して、goto-lineという文字を入力しEnterキーを押して、37という数字を入力して、再びEnterキーを押してください) 先頭のセミコロンを削除しコメントを外しましょう。つまり37行目は以下のようになります。

#+BEGIN_SRC elisp
(setq initial-frame-alist '((top . 0) (left . 0) (width . 120) (height . 80)))
#+END_SRC

　 ~width~ や ~height~ の横の値(上では120、80となっている部分)を変更することで、次にEmacsを開いたときのウィンドウのサイズを変更することができます。試しに以下のように件の値を小さくしてみましょう。

#+BEGIN_SRC elisp
(setq initial-frame-alist '((top . 0) (left . 0) (width . 80) (height . 20)))
#+END_SRC

　 ~width~ と ~height~ の値を変更したところで、C-x C-s でファイルを保存することができます。このシーケンスを実行するとEmacsのミニバッファに ~Wrote /Users/snuffleupagus/.emacs.d/customizations/ui.el~ といった文が表示されると思います。

　ファイルを保存したら、Emacsを終了してもう一度起動してください。おそらく起動時の画面はとても小さなサイズになり、図2-6のような形になるはずです。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/tinemacs.png][図2-6:高さと幅を指定することで、Emacsを開くたびにウィンドウサイズが更新されます]]

　Emacsが好きなサイズで起動するまで、同じプロセスを2,3回実行してみてください。あるいは37行目をコメントアウトして保存し、Emacsを再起動してください(Emacsをデフォルトの幅と高さで開きます)。ui.elの編集と保存が終わったら ~C-x k~ でバッファを閉じることができます。もし何らかの不具合があればこの章の =構成= の項目から再びファイルを設置し直すことでEmacsを元に戻すことができるでしょう。 

　要約をすると
1. Emacsではバッファ内で編集作業を行う
2. バッファを移動する際には ~C-x b~ とバッファ名を入力する
3. バッファを新規作成するためには ~C-x b~ で新しいバッファ名を入力する
4. ファイルを開く際には、 ~C-x C-f~ を押し、ファイルのパスを入力する
5. ファイルを保存する際には、 ~C-x C-s~ を入力する
6. ファイルを新しく作る際には、 ~C-x C-f~ を入力し、新しく作成したいファイルのパスを入力する。バッファを保存した際に、Emacsは入力した新しいファイルを作成しバッファの内容を保存する。

** キーバインドとモード
　ここまで長い道のりを進んできて、私達は基本的なエディタと同様にEmacsを利用することができるようになりました。これはサーバ上でEmacsを利用する必要がある場合や、Emacsを無理やり使用させられるような場合には役立つことでしょう。

　しかし、実際にEmacsを用いて生産性を向上させるためには、重要なキーバインディングなどについての情報を知っておく必要があるでしょう。まず私達はEmacsのモードについて学びます。そしてその次にいくつかの重要な用語についての確認を行い、非常に有用なキーバインド達を調べていきます。

*** EmacsはLispのインタプリタです
　 =キーバインド= という言葉の由来は、Emacsが =キーストロークをコマンドにバインドする= という意味からの派生です。これはelip関数が実行されているという意味です。（その意味ではコマンドと関数は言葉は交換可能であるのかもしれません）例えば ~C-x b~ とは関数 ~switch-to-buffer~ にバインドされています。同様に ~C-x C-s~ は ~save-file~ にバインドされています。

　しかし、Emacsはそれ以上に素晴らしい機能を持っています。単純なキーストロークである、 ~f~ や ~a~ ですら関数となり得り、私達が =self-insert-command= として関数を割り当てることが可能です。

　Emacsからすれば、すべての関数は平等に生成され、すべての関数を定義することも可能です。あまりおすすめできませんが、 ~save-file~ のようなコアな関数も再定義することが可能です。

　関数を再定義できる理由には、Emacsはコード編集機能をロードしているLispインタプリタに過ぎないという事実があります。Emacsはほとんどがelispで書かれているため、Emacsからすれば、 ~save-file~ もただの関数であり、 ~switch-to-buffer~ もこれと等価に実行可能です。それどころかあなた自身が関数を作成しそれをEmacsに組み込まれている関数と同様に実行することも可能であり、実行中のEmacsの動作をそのEmacs内でelispを書くことで変更できます。

　このような強力なプログラミング言語を用いてEmacsを変更することで、Emacsは非常に柔軟で自由な形になり、それがEmacsが私達を魅了する理由の一つです。もちろんこのすべての機能を知るためには表面的なものでさえ複雑な部分が見受けられ、学習には時間がかかる可能性があります。しかし、Emacsの根底には、Lispの洗練された単純さと、それに伴う無限の可能性です。この変更可能性には機能の作成と再定義だけにとどまらず、キーバインドの作成、再定義、削除すら可能です。キーバインドとはキーストロークと関数を関連付けるテーブルのエントリに過ぎないため、このテーブルは自由に変更ができるのです。

　また、 ~M-x~ function-name (例えば、 ~M-x save-buffer~)を使用して、特定のキーバインドなしでコマンドを名前から実行することもできます。 =M= は現代のキーボードで言うならば、WindowsやLinuxではaltキー、MacではOptionキーに割り当てられています。 ~M-x smex~ を実行すると、実行する別のコマンドを入力することを求められます。

　キーバインドと関数を理解したので、どのモードがどのように動作するのかを見ていきましょう。

*** モード
　Emacsのモードは様々な種類のファイルを編集する際に役立つようにパッケージ化されたキーバインドと関数のコレクションです。(モードは、Emacsに構文のハイライト機能などを提供することもありますが、それは二次的な意味を持っているため、ここでは扱いません)

　例えば、Clojureファイルを編集する際には、EmacsではClojureモードをロードします。この文章を書いている筆者はMarkdownファイルを書いているのでMarkdownモードを利用しています。このモードでは、Markdownの作業に固有の便利なキーバインドがたくさんあります。Cojureを編集するときは、現在のバッファをREPLにロードしてコンパイルするために、 ~C-c C-k~ などのような一連のClojureモード固有のキーバインドを知っておくことが最善です。

　モードには、 =メジャーモード= と =マイナーモード= のに種類があります。ClojureモードやMarkdownモードはメジャーモードです。メジャーモードは通常、ファイルを開くときにEmacsによって設定されますが、関連するEmacsコマンド(~M-x clojure-mode~ や ~M-x markdown-mode~ など)を実行することで明示的にモードを設定することができます。一つのバッファについてアクティブなメジャーモードは一つだけです。

　メジャーモードは特定のファイルタイプや言語に特化していますが、対してマイナーモードは通常、ファイルタイプ全体で便利な機能を提供します。例えば、abbrevモードやyasnippetモードは割り当てられた予約語を元に補完処理を行います。マイナーモードは複数のものを同時にアクティブにすることができます。

　図2-7に示すように、モードライン上でアクティブなモードを確認することができます。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-mode-line.png][図2-7：モードラインはどのモードがアクティブであるかを示しています]]

　ファイルを開いてもEmacsがメジャーモードがロードされないとき、それはEmacsがそのメジャーモードに関するパッケージを入手していないときです。このパッケージのインストールについて次に説明します。

*** パッケージのインストール
　多くのモードはパッケージとして配布されています。これはパッケージリポジトリに格納されたelispファイルの集合体です。この章の冒頭にインストールしたEmacs 24(25)では、パッケージの参照とインストールが非常に簡単です。 ~M-x packag-list-packages~ は利用可能なほぼすべてのパッケージを表示します。しかしその前に、 ~M-x package-refresh-contents~ によって最新のパッケージリストを得ておくことをおすすめします。また、 ~M-x package-install~ から任意のパッケージを指定することでそれをインストールすることもできます。

　あなた自身のelispファイルやインターネット上のファイルをロードすることで、Emacsをカスタマイズすることもできます。「[[http://www.masteringemacs.org/articles/2010/10/04/beginners-guide-to-emacs/][Emacsの初心者向けガイド]]」を見てみると良いかもしれません。カスタマイズのロード方法には、ガイドの記事の下の方にある「新しいパッケージをロードする」項を参照してください。

** 編集におけるコアな用語とキーバインド
　テキストエディタのようにEmacsを使いたいだけなら、このセクションを飛ばしていただいても構いません。しかし、このセクションを見ることであなたはEmacsの素晴らしい機能のいくつかを知ることができるでしょう。ここでは、重要なEmacsの用語についての説明をします。具体的には、テキストの選択、切り取り、コピー、貼り付けの方法。バッファの効率の良い切り替え方法などです。
　
　まず、Emacsで新しいバッファを開き(~C-x b~ でしたね)、それを =jack-handy= という名前にしましょう。次に、以下のjack Handyの言葉を入力してみましょう。（後述しますが、コピーをした状態でバッファ内で ~C-y~ をすると貼り付けられます)

#+BEGIN_SRC text
If you were a pirate, you know what would be the one thing that would　really make you mad? Treasure chests with no handles. How the hell are　you supposed to carry it?!

The face of a child can say it all, especially the mouth part of the face.

To me, boxing is like a ballet, except there's no music, no choreography, and the dancers hit each other.
#+END_SRC

　以降はこの文章を弄ることで説明をしていきます。

*** ポインタ
　あなたがここまで順番通りにEmacsの設定を行ってきたならば、Emacsのバッファに小さな矩形が表示されていると思います。これが =カーソル= であり、 =ポインタ= の図形表示です。ポインタはすべての動作の開始点となります。ここからテキストが挿入され、ほとんどの編集コマンドはポインタに関連して発生します。また、カーソルが文字の上に置かれているように見えますが、実際はその文字と前の文字との間にポインタがあります。

　例えば、 =If you were a pirate= の =f= の上にカーソルが置かれているとき、ポインタは =I= と =f= の間にあります。つまり、ここで =a= を入力すれば =Iaf= となります。また、 =f= の上にカーソルを合わせたまま ~C-k~ を押すと、それ以降の行の文字が消えてしまいます。つまりこのコマンドは、テキストの ~kill-line~ を実行したことになります。(後で詳細については説明します) その変更は ~C-/~ でもとに戻すことができます。

*** 移動
　矢印キーを使用して他のエディタと同様にポイントを移動できますが、表2-1に示すように、多くのキーバインドによって効率的に移動することもできます。

#+NAME: 表2-1
#+CAPTION: テキスト内で移動するためのキーバインド
|-------+----------------------------------------------------|
| キー  | 説明                                               |
|-------+----------------------------------------------------|
| C-a   | 行頭に移動する                                     |
| M-m   | その行の空白ではない字の先頭に移動する             |
| C-e   | その行の末尾に移動する                             |
| C-f   | 一文字前に進む                                     |
| C-b   | 一文字後ろに進む                                   |
| M-f   | 一単語前に進む                                     |
| M-b   | 一単語後ろに進む                                   |
| C-s   | このコマンドの後に入力された文字列の検索(前向き)   |
| C-r   | このコマンドの後に入力された文字列の検索(後ろ向き) |
| M-<   | バッファの先頭に移動する                           |
| M->   | バッファの末尾に移動する                           |
| M-g g | このコマンドの後に入力された行数にジャンプする     |
|-------+----------------------------------------------------|

　さっそくこれらの機能を先ほど作成した =jack-handy= のバッファに対して行ってみましょう。

*** 範囲選択
　Emacsではテキストの選択という考えではなく、領域の選択という考え方を採用しています。領域を作成するには、 ~C-SPC~ でマークを設定します。次にポインタを移動すると、マークとポイントの間のすべての部分が領域になります。これは他のテキストエディタの、Shiftキーで領域選択ができる機能に似ています。

　例えば、 =jack-handy= バッファで以下のようにしてみましょう。

1. バッファの先頭に行きましょう(~M-<~) 
2. C-SPCを押しましょう
3. ~M-f~ を二回押して、二単語分の領域を作ります
4. バックスペースキーを押すことでその領域が削除されます(つまり、 =If you= が削除されます)

　Shiftキーではなくマークを使って領域選択を行う利点の一つは、マークを設定した後にEmacsの移動コマンドを自由に使用することができることです。例えばマークを設定して、 ~C-s~ を使用し、任意の文字まで飛んで、その範囲までを選択することができます。つまりShiftキーを離さないように注意して文字列を探す必要がなくなるのです。

　領域選択では、ある操作をバッファの限られた領域内だけに限定することもできます。

1. =The face of child can say= という部分を範囲選択してください。
2. その上で ~M-x replace-string~ と入力し、その次に ~face~ ~head~ とEnterで繋げて入力することで領域内の =face= を =head= に置換することができます。

　なお、 ~replace-string~ コマンドそのものは指定された領域に対して効果を発揮する関数であり、上のような動作が通常の利用方法です。

*** 削除とキルリング
　多くのアプリケーションにおいて私達はテキストを切り取ることができますし、コピーと貼り付けを行うこともできます。切り取りとコピーはクリップボードに選択したものを追加して、貼り付けはクリップボードの内容を現在のアプリケーションにコピーします。Emacsではこのような機能も盛り込んでおり、領域を切り取り、貼り付けることができますし、コピーすることもできます。

　ところがEmacsにおけるこの3つの動作はやや特殊なものがあります。つまり典型的な切り取り/コピー/貼り付けができるクリップボード機能郡ではできないタスクの実行が可能なのです。

　Emacsはキルリングという場所に複数のテキストブロックを格納しています。これは昔に切り取られてしまったテキストを検索することができるという素晴らしい機能を持っています。この機能を実際に体験してみましょう。

1. 最初の行の、 =Treasure= という単語の上に領域を作成します
2. ~M-w~ を入力し ~kill-ring-save~ します。これはコピーに似た動作をし、該当領域をバッファから削除することなくキルリングに追加します。
3. 最後の行の、 =choreography= の先頭にポインタを合わせてください
4. ~M-d~ を入力し、 ~kill-word~ を実行します。単語単位での削除が可能で、 =choreography= の単語が削除されたはずです。
5. 同じ場所で ~C-y~ コマンドを使ってキルリングにあるテキストをバッファに貼り付けましょう。今回は先程削除してキルリングに追加されていた =choreography= が追加されたはずです。
6. 同様に ~M-y~ コマンドを使うことで今度は =choreography= という先程貼り付けた単語が消えて、その前にキルリングに保存していた =Treasure= が追加されました。

　ここで非常に有用な切り取りや貼り付けのキーバインドを表2-2に示します。

#+CAPTION: 切り取りや貼り付けに関するキーバインド
#+NAME: 表2-2
|------+----------------------------------------|
| キー | 説明                                   |
|------+----------------------------------------|
| C-w  | 選択範囲の切り取り                     |
| M-w  | 選択範囲のキーリングへの追加（コピー） |
| C-y  | 貼り付け                               |
| M-y  | 貼付けするテキストの選択               |
| M-d  | 単語単位での切り取り                   |
| C-k  | 行の削除                               |
|------+----------------------------------------|

*** 編集とヘルプ
　表2-3は、スペーシングとテキストの補完を扱うために知っておくべき、便利な編集キーバインドを示しています。

#+CAPTION: その他の便利な編集用キーバインド
#+NAME: 表2-3
|------+---------------------------------------------------------|
| キー | 説明                                                    |
|------+---------------------------------------------------------|
| Tab  | 行のインデント                                          |
| C-j  | 新しい行に移動してインデントを行う。EnterとTab          |
| M-/  | yasnippetなどを使っている際の補完機能を呼ぶキーバインド |
| M-\  | ポインタ周辺の無駄なスペースを削除するためのコマンド    |
|------+---------------------------------------------------------|

(日本語ユーザへの注記：M-\はMozcなどの日本語入力切替のためのキーバインドになっていることが多々あるため、意図した動作をしない可能性があります。)

　Emacsは組み込みで素晴らしいヘルプを持っています。以下の2つのキーがその代表となるヘルプのためのキーバインドです。

#+CAPTION: 組み込みのヘルプキーバインド
#+NAME: 表2-4
|----------------------+--------------------------------------------------------|
| キー                 | 説明                                                   |
| C-h k (キーバインド) | キーバインドについての説明をします。                   |
|                      | コマンド入力後に調べたいキーバインドを入力してください |
| C-h f                | 関数についての説明をします。                           |
|----------------------+--------------------------------------------------------|

　ヘルプテキストは新しいウィンドウに表示されます。このことについては後に説明を行います。今のところは、ヘルプウィンドウは ~C-x o q~ (またはヘルプウィンドウ上で ~q~) でこれを閉じることができる、ということを確認してください。

** EmacsでClojureを扱う
　次に、Emacsを使ってClojureアプリを効率的に開発する方法を説明します。まずEmacsに接続されたREPLプロセスの開始方法やEmacsウィンドウの操作の両方を学んでいきます。次に式の評価、ファイルのコンパイル、及びその他の便利なタスクの実行に役立つキーバインドの豊富さについても言及します。最後に、Clojure開発時に起こるエラーの処理方法と、オプションのマイナーモードであるPareditのいくつかの機能を紹介します。これは、Lisp系列の言語でコードを記述したり編集したりするのに便利です。

　Clojureコード自体を学んでいきたい場合は先に進んで大丈夫です。もし何かに躓いた際には何度でも読み返してみてください。

*** REPLを起動してみよう
　第1章で学んだように、REPLでは、対話形式でClojureコードを記述し実行することができます。REPLは実行中のClojureプログラムであり、プロンプトを表示して入力を読み取り、評価し、結果を出力し、プロンプトに戻っていきます。第1章ではREPLを ~lein repl~ を用いてターミナルから起動しましたが、このセクションではEmacsから直接REPLを起動してみます。

　EmacsをREPLに接続するには、Emacsの[[https://github.com/clojure-emacs/cider/][CIDER]] を使う必要があります。この章の前半の設定手順に従っている場合にはすでにインストールしてありますが、 ~M-x package-install Enter CIDER~ を用いて再インストールすることもできます。
　
　CIDERを使うことでEmacs内でREPLを利用することができ、より効率的にREPLと対話できるようになるキーバインドが提供されます。早速REPLセッションを確立してみましょう。Emacsを使用して、第1章で作成した =clojure-noob/src/clojure-noob/core.clj= ファイルを開きます。(作り忘れた場合などは、 ~M-x shell~ でEmacs内からシェルを開くことができるのでそこで作成すると良いでしょう) 次に、 ~M-x cider-jack-in~ コマンドでREPLを開始します。ほんの少し待った後にREPLが開始され、新しいバッファが作成されます。そして、図2-8のような表示が出てくるはずです。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/cider-jack-in.png][図2-8:~M-x cider-jack-in~ を実行した後のEmacsの外観]]

　今度は2つのウィンドウが見えます。 =core.clj= ファイルは左側にあり、REPLは右側にあります。Emacsがこのように半分に分割されたことを今まで見たことがなかったとしても心配しないでください。Emacsがウィンドウを如何にして分割しているのかは後で説明を行います。さて、REPLでコードを評価してみましょう。以下の太字の行を入力してみてください。コメントアウトされている部分がEnterキーを押したときにREPLに表示される結果です。コードの内容については次の章で説明を行いますので今は深く考えなくて構いません。

#+BEGIN_SRC clojure
(+ 1 2 3 4)
; => 10
(map inc [1 2 3 4])
; => (2 3 4 5)
(reduce + [5 6 100])
; => 111
#+END_SRC

　このREPLは第一章で使ったものと同じように使用できます。更に詳しい機能について説明をしていきたいところではありますが、ここでEmacsの画面を分割して作業をする方法について説明します。

*** Emacsのウィンドウとフレームについて
　Emacsがフレームとウィンドウをどの湯に扱うのかを説明し、ウィンドウ関連の重要なキーバインドをいくつか紹介します。Emacsのウィンドウ操作に慣れている場合は飛ばしても構いません。

　Emacsは様々な用語を慣れ親しんだ意味とはかなり異なった形で使用しています。通常 =ウィンドウ= と呼ばれているものはEmacsでは =フレーム= と呼ばれます。Emacsは =フレーム= を呼び出しその中で複数の =ウィンドウ= に分割することができます。複数のウィンドウに分割することで、一度に複数のバッファを表示することができます。これはすでに ~cider-jack-in~ コマンドですでに経験していることです。(図2-9を参照)

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/emacs-windows.png][図2-9:Emacsでは、フレームにウィンドウが含まれます]]

　表2-5は、フレームとウィンドウを操作するためのいくつかのキーバインドを示しています。

#+CAPTION: Emacsウィンドウのキーバインド
#+NAME: 表2-5
|-------+--------------------------------------------------------------------------------------------------------------------------------------------|
| キー  | 説明                                                                                                                                       |
|-------+--------------------------------------------------------------------------------------------------------------------------------------------|
| C-x o | カーソルを別のウィンドウに切り替えます。これを使ってClojureファイルとREPLを切り替えてみましょう                                            |
| C-x 1 | 他のウィンドウを削除して現在のウィンドウのみをフレームに残します。これはバッファを消しているわけではいので、作業が消えるわけではありません |
| C-x 2 | フレームを上下に分割します                                                                                                                 |
| C-x 3 | フレームを左右に分割します                                                                                                                 |
| C-x 0 | 現在のウィンドウを削除します                                                                                                               |
|-------+--------------------------------------------------------------------------------------------------------------------------------------------|

　以上のEmacsウィンドウについてのキーバインドを試してみることをおすすめします。例えば、Clojureファイルにカーソルを置き、 ~C-x 1~ を使用します。もう一方のウィンドウは消え、Clojureコードだけが表示されます。次に以下を実行してみましょう。

1. ~C-x 3~ を使用してウィンドウを左右に分割しましょう
2. 右のウィンドウに切り替えるには ~C-x o~ を使います
3. 右のウィンドウでこの内容をCIDERバッファに切り替えるには、 ~C-x b *cider-repl*~ を使用します

　少し試してから、Emacsに左側はClojureコードを、右側にCIDERバッファが開かれているように設定しましょう。ウィンドウとフレームの詳しい情報について知りたい場合には [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Windows.html][Emacsのマニュアル]] を参照してください。

　Emacsのウィンドウを移動できるようになったので、Clojure開発のキーバインドを学びましょう。

*** 豊富で有用なキーバインド
　ここまでであなたはClojureのプロジェクトをEmacsで使う際の真の力となるキーバインドたちを学ぶための準備を整えました。これから学ぶコマンドは、僅かなキーストロークによってコードを評価、調整、コンパイル、実行することができます。まず式を素早く評価する方法から見ていきましょう。

　 =core.clj= の一番下に以下を追加してみてください。

#+BEGIN_SRC clojure
(println "Cleanliness is next to godliness")
#+END_SRC

　 ~C-e~ を用いてこの行末まで移動し、 ~C-x C-e~ (または ~C-c C-e~)を実行してみましょう。図2-10に示すように、 =Cleanliness is next to godliness= はCIDERバッファに表示されます。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/cider-eval-last-expression.png][図2-10:REPLで別のバッファからのコードを即座に評価します]]

　キーバインド ~C-x C-e~ (~C-c C-e~)シーケンスは ~cide-eval-last-expression~ コマンドを実行します。名前からわかるように、このコマンドは直前の式をREPLに送り、REPLはそれを評価します。なお ~C-u C-x C-e~ は、ポインタの後に評価の結果を印刷します。

　さて、私達が第1章で書いた関数である ~-main~ を実行して見ましょう。小さなティーポットからの挨拶が返ってくるはずです。

　 =core.clj= バッファ内で ~C-c M-n~ シーケンスを実行するとREPLの名前空間をそのファイルの先頭に書かれている名前空間に切り替えることができます。REPLのプロンプトを見ると、 =clojure-noob.core>= という文字を見ることができます。名前空間について詳しいことを私達はまだ学んでいませんが、名前空間が関数などの名前の競合を避けるためのメカニズムであるということだけを知っていれば十分です。次にREPLのプロンプトに直接 (-main) と入力してみてください。REPLは =I'm a little tepot!= という返事をしてきます。

　さて、新しい関数を作成して実行してみましょう。 =core.clj= の一番下に以下を追加してください。

#+BEGIN_SRC clojure
(defn train
  []
  (println "Choo choo!"))
#+END_SRC

　完了したら、ファイルを保存して ~C-c C-k~ を使用して、REPLセッション内で現在のファイルをコンパイルします。(REPLが変更を認識するようにコードをコンパイルする必要があるのです) REPLで ~(train)~ を実行すると、 ~Choo choo!~ と返事をします。

　REPLの中で ~C-↑~ を試して見てください。 ~C-↑~ ~C-↓~ はREPL履歴を循環します。REPL履歴には、REPLで評価したすべてのClojureの式が含まれています。

　Macユーザは ~C-（矢印キー）~ は別のキーバインドとしてマッピングされています。こちらの設定を変更しないと異なった動作を行う可能性があります。

　最後にこれを試してみてください。

1. REPL上に  ~(-main~ と閉じ括弧を忘れて入力してみてください
2. ~C-Enter~ を押します

　CIDERは自動的に括弧を閉じて式を評価する必要があります。これはCIDERが非常に多くの括弧を扱う上で用意されているちょっとした便利な機能です。

　CIDERには、Clojureを学ぶ際に重要ないくつかのキーバインドがあります。 ~C-c C-d C-d~ を押すと、その時点のシンボルのドキュメントが更新され、検索する時間を短縮することができます。ドキュメントを確認し終わったら、 ~q~ を押してドキュメントバッファを閉じます。 ~M-.~ キーバインドはポインタの下にあるシンボルのソースコードに移動し、 ~M-,~ はもとのバッファの位置に戻ることができます。最後に ~C-c C-d C-a~ では、任意の関数名とドキュメントのテキストを調べることが可能です。これは名前を正確に覚えていない関数を見つけるために最適な方法です。

　[[https://github.com/clojure-emacs/cider/][CIDER README]] には、主要なキーバインドの包括的なリストがありますが、今の所重要なものは表2-6と表2-7に示しています。

#+CAPTION: Clojureバッファのキーバインド
#+NAME: 表2-6
|-------------+------------------------------------------------------------|
| キー        | 説明                                                       |
|-------------+------------------------------------------------------------|
| C-c M-n     | 現在のバッファの名前空間に切り替えます                     |
| C-x C-e     | 現在のポインタの関数を評価する                             |
| (C-c C-e)   |                                                            |
| C-c C-k     | 現在のバッファをコンパイルします                           |
| C-c C-d C-d | 選択しているのシンボルのドキュメントを表示します           |
| M-. と M-,  | 選択しているシンボルのソースコードに移動し                 |
|             | 元のバッファに戻ります                                     |
| C-c C-d C-a | 任意のシンボルの検索                                       |
|             | 関数名とドキュメント全体に渡って任意のテキストを見つけます |
|-------------+------------------------------------------------------------|

#+CAPTION: CIDERバッファのキーバインド
#+NAME: 表2-7
|-----------+------------------------|
| キー      | 説明                   |
|-----------+------------------------|
| C-↓ C-↑ | REPL履歴を循環します   |
| Enter     | 括弧を閉じて評価します |
|-----------+------------------------|

*** エラーの処理方法
　このセクションではいくつかのバグのあるコードを書いて、Emacsがどのようにそれに応答するのか、そしてエラーからどのように復旧するのかを見ることができます。REPLバッファと =core.clj= バッファの両方でこれを行います。REPLから始めてみましょう。プロンプトで ~(map)~ と入力してEnterキーを押します。図2-11のようなものが表示されます。

[[https://www.braveclojure.com/assets/images/cftbat/basic-emacs/cider-error.png][REPLで不正なコードを実行すると起こる画面]]

　画面のように、 ~map~ に引数を指定しないで呼び出すと、Clojureはエラーコードを返します。REPLバッファに ~ArityException~ のエラーメッセージとともに左ウィンドウには怪文書のようなテキストが表示されます。それらは =スタックトレース= であり、実際に例外を投げた関数とその関数を呼び出した関数を関数呼び出しスタックに表示しています。

　Clojureのスタックトレースは、初心者では解読が難しいことがあります。しかしこれから有用な情報を取得する方法を学びます。CIDERを使用するとスタックトレースをフィルタすることができ、それによって無駄な情報を削ぎ落とすことができます。 =*cider-error*= バッファの二行目を見てください。Clojure、Java、REPL、Tooling、Duplicates、Allというフィルタがあります。各オプションをクリックすることでフィルタを有効にすることができます。各スタックトレースの行をクリックして対応するソースコードにジャンプすることもできます。

　左側のウィンドウのスタックトレースを閉じる方法は次のとおりです。

1. ~C-x o~ を使用してウィンドウを切り替えます
2. ~q~ を押してスタックトレースを閉じ、自動的にCIDERに戻ることができます
　
　エラーを再表示するためには、 =*cider-error*= バッファに切り替えてください。ファイルをコンパイルしようとすると、エラーメッセージが表示されることもあります。コンパイル時のエラーを見るために、次の手順を行ってみましょう。

1. ~(map)~ を =core.clj= ファイルの末尾にに追加してください。
2. ~C-c C-k~ を使用してコンパイルします

　前に見たものに似た =*cider-error*= バッファが表示されると思います。ここでも ~q~ でスタックトレースを閉じます。

*** Paredit
　Clojureコードのバッファにコードを書いている途中に、例えば閉じ括弧が自動的に入力されるなどの不思議な現象に見舞われたかもしれません。

　これは、 =paredit-mode= による機能です。 =Lisp= コードにおける括弧管理をより効率的にするためのマイナーモードです。 =Paredit= は、すべての括弧、二重引用符、そして大括弧が閉じられていることを必ず保証してくれます。

　 =Paredit= はすべての括弧で作成された構造を簡単に移動したり変更したりするためのキーバインドも提供しています。次のセクションでは最低限覚えておくべき有用なキーバインドについて説明しますが、 [[https://github.com/georgek/paredit-cheatsheet/blob/master/paredit-cheatsheet.pdf][ドキュメント]] か包括的なチートシートを参照することができます。（このドキュメントは赤いパイプがポインタを示しています）

　しかしこのモードに慣れていない場合、 =paredit= は迷惑な機能であるように感じるでしょう。その場合には、 ~M-x paredit-mode~ で機能を無効化することができます。また、再び同じシーケンスを行うことで機能を有効にすることもできます。

　次のセクションでは有用なキーバインドについて紹介します。

*** ラッピングとスラーピング
　 =ラッピング= はポインタを括弧で囲みます。 =スラーピング= は閉じ括弧の位置を移動します。例えば以下のような操作が可能になります。

#+BEGIN_SRC clojure
(+ 1 2 3 4)
#+END_SRC

　から、

#+BEGIN_SRC clojure
(+ 1 (* 2 3) 4)
#+END_SRC

　まず2をラッピングしてみましょう。2の手前にポインタを合わせてください。この位置をここでは =|= パイプで表しています。

#+BEGIN_SRC clojure
(+ 1 |2 3 4)
#+END_SRC

　次に、 ~M-(~ ~paredit-wrap-round~ コマンドを使うと、以下のような結果になります。

#+BEGIN_SRC clojure
(+ 1 (|2) 3 4)
#+END_SRC

　アスタリスクとスペースを追加してみましょう。

#+BEGIN_SRC clojure
(+ 1 (* |2) 3 4)
#+END_SRC

　 ~C-->~ で3をスラーピングすることができます。

#+BEGIN_SRC clojure
(+ 1 (* |2 3) 4)
#+END_SRC

　これを行うことで、矢印キーを使って括弧の移動や拡張を自由に行うことができます。
　
*** バーフィング
　もしあなたが間違って4までをスラーピングしてしまった場合は、2や3のある括弧内で ~C-<-~ をすることで戻すことができます。そしてこれをバーフィングと呼びます。

#+BEGIN_SRC clojure
(+ 1 (|* 2 3 4))
#+END_SRC

　次に ~C-<-~ を使います。

#+BEGIN_SRC clojure
(+ 1 (* 2 3) 4)
#+END_SRC

　ここまでであなたは =paredit-mode= で括弧を自在に操ることができるようになりました。

*** その他の移動
　多くの場合において、Lisp方言を書くときは、次のような式を書くことになると思います。

#+BEGIN_SRC lisp
(map (comp record first)
     (d/q '[:find ?post
            :in $ ?search
            :where
            [(fulltext $ :post/content ?search)
             [[?post ?content]]]]
          (db/db)
          (:q params)))
#+END_SRC

　この種の式では、ある部分式から次の部分式に素早くジャンプできると便利です。括弧の開始地点の直前にポインタを置くと、 ~C-M-f~ は閉じ括弧に移動することができます。同様に、ポイントが閉じ括弧にある状態で ~C-M-b~ を使うと始めの括弧に移動します。

　表2-8に今までに学んだ ~paredit-mode~ のキーバインドをまとめます。

#+CAPTION: Pareditのキーバインド
#+NAME: 表2-8
|------------------+-----------------------------------|
| キー             | 説明                              |
|------------------+-----------------------------------|
| M-x paredit-mode | paredit-modeを切り替えます        |
| M-(              | paredit-wrap-round 機能を使います |
| C-->             | 閉じ括弧を右にずらします          |
| C-<-             | 閉じ括弧を左にずらします          |
| C-M-f C-M-b      | 開き/閉じ括弧に移動します         |
|------------------+-----------------------------------|

** さらなる学習をするには
　Emacsは最古参のエディタの一つであり、その魅力を知った暁には間違いなくあなたの愛用のエディタになります。最初のハードルこそ高く感じるかもしれませんが、そこを超えてしまえば、あなたは一生このエディタを使ったことによる多大な恩恵を受けられるはずです。

　Emacsを開くたびに私達は何らかのインスピレーションを受けます。仕事場に入った職人のようにこの眼の前に開かれた可能性に感じ入ります。私は、自身のために進化した環境の快適さを感じています。キーバインドやパッケージは日々のアイデアに生き生きとしたものを与えてくれます。

　これらの資料はEmacsでの旅を続ける際に役立ちます。

1. [[http://www.gnu.org/software/emacs/manual/html_node/emacs/index.html#Top][Emcasマニュアル]]は、Emacsについてのほぼ全てに関する丁寧な説明が行われています。時間があるときに目を通してみると良いでしょう。
2. Mickey Petersenによる [[http://www.masteringemacs.org/reading-guide/][Mastering Emacs]] はEmacsについての資料の中で最良のものの一つでしょう。
3. より視覚的な資料として、 Sacha Chuaが手がけた [[http://sachachua.com/blog/wp-content/uploads/2013/05/How-to-Learn-Emacs8.pn ][Emacsを学ぶ方法]] をおすすめします。
4. 組み込みのチュートリアルである ~C-h t~ を押すだけです

(翻訳者からの注釈：日本でEmacsのチュートリアル本を買う際には発行日に注意してください。Emacsのバージョンは日々更新されているため、古いキーバインドやパッケージの上位互換が一般化している場合が多くあります)

** この章のまとめ
　素晴らしいことにあなたはClojure言語を学ぶ環境、Emacsについての理解をほとんど極めることができました。EmacsはLispのインタプリタであり、elisp関数のショートカットとしてシーケンスがあり、モードはキーバインドや関数のコレクションです。Emacs特有のバッファ、ウィンドウ、領域、切り取りやコピー、貼り付けについてをマスターしました。最後に、CIDERとpareditを用いたClojureの便利な作業方法について学びました。

　Emacsの知識を本格的に身につけることのできたということは、Clojureを本格的に学ぶことのできる環境が整ったということです。次の章からはいよいよClojureという言語を詳しく見ていくことになります。

* 第3章

